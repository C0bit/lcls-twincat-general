<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_BasicStats" Id="{dd720d4e-bff0-4eac-9bd3-db3174a49483}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_BasicStats
(*
	Minimalist Array Stats for LREALs
	2019-10-10 Zachary Lentz
	
	Calculates the most basic stats for an array and provides pytmc control points.
	This is an alternative to the TC3 Condition Monitoring library which requires an
	additional license and had a more complicated interface.
*)
VAR_IN_OUT
	// Input array of floats
	{attribute 'pytmc' := '
		pv: STATS:DATA
		io: i
	'}
	aSignal: ARRAY[*] OF LREAL;
END_VAR
VAR_INPUT
	// If TRUE, we will update the outputs based on aSignal
	bEnable: BOOL;
	// If nonzero, we will only pay attention to the first nElems items in aSignal
	{attribute 'pytmc' := '
		pv: STATS:NELM
		io: i
	'}
	nElems: UDINT;
END_VAR
VAR_OUTPUT
	// Average of all values in the array
	{attribute 'pytmc' := '
		pv: STATS:MEAN
		io: i
	'}
	fMean: LREAL;
	// Standard deviation of all values in the array
	{attribute 'pytmc' := '
		pv: STATS:STDEV
		io: i
	'}
	fStDev: LREAL;
	// Root mean square of all values in the array
	{attribute 'pytmc' := '
		pv: STATS:RMS
		io: i
	'}
	fRMS: LREAL;
	// Largest value in the array
	{attribute 'pytmc' := '
		pv: STATS:MAX
		io: i
	'}
	fMax: LREAL;
	// Smallest value in the array
	{attribute 'pytmc' := '
		pv: STATS:MIN
		io: i
	'}
	fMin: LREAL;
	// Largest array element subtracted by the smallest
	{attribute 'pytmc' := '
		pv: STATS:RANGE
		io: i
	'}
	fRange: LREAL;
END_VAR
VAR
	nIndex: DINT;
	nElemsSeen: UDINT;
	fSum: LREAL;
	fSquareSum: LREAL;
	fSquareMean: LREAL;
	fVarianceSum: LREAL;
	fVarianceMean: LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF bEnable THEN
	// First pass through aSignal, get sum, square sum, mean, rms, max, min
	nElemsSeen := 0;
	fSum := 0;
	fSquareSum := 0;
	fMax := aSignal[LOWER_BOUND(aSignal, 1)];
	fMin := fMax;
	FOR nIndex := LOWER_BOUND(aSignal, 1) TO UPPER_BOUND(aSignal, 1) DO
		nElemsSeen := nElemsSeen + 1;
		fSum := fSum + aSignal[nIndex];
		fSquareSum := fSquareSum + aSignal[nIndex] * aSignal[nIndex];
		IF aSignal[nIndex] > fMax THEN
			fMax := aSignal[nIndex];
		ELSIF aSignal[nIndex] < fMin tHEN
			fMin := aSignal[nIndex];
		END_IF
		IF nElems > 0 AND nElemsSeen >= nElems THEN
			EXIT;
		END_IF
	END_FOR
	IF nElemsSeen > 0 THEN
		fMean := fSum / nElemsSeen;
		fSquareMean := fSquareSum / nElemsSeen;
		fRMS := SQRT(fSquareMean);
		fRange := fMax - fMin;

		// Second pass through aSignal, get the sum of the variances and then the stdev
		nElemsSeen := 0;
		fVarianceSum := 0;
		FOR nIndex := LOWER_BOUND(aSignal, 1) TO UPPER_BOUND(aSignal, 1) DO
			nElemsSeen := nElemsSeen + 1;
			fVarianceSum := fVarianceSum + (aSignal[nIndex] - fMean) * (aSignal[nIndex] - fMean);
			IF nElems > 0 AND nElemsSeen >= nElems THEN
				EXIT;
			END_IF
		END_FOR
		IF nElemsSeen > 1 THEN
			fVarianceMean := fVarianceSum / (nElemsSeen - 1);
			fStDev := SQRT(fVarianceMean);
		END_IF
	END_IF
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>