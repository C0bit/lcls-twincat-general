<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.12">
  <POU Name="FB_Logger" Id="{227c1bce-209d-4aad-8160-124282bb6370}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Logger
VAR_INPUT
	i_CloseSocket	:	BOOL := FALSE;
	i_bReset		:	BOOL := FALSE;
END_VAR
VAR
	fbUDPSocketManager	:	FB_ConnectionlessSocket;
	stUDPSocket			:	T_HSOCKET;
	fbUDPSocketSend		:	FB_SocketUdpSendTo;
	sOutgoingMesg		:	T_MaxString;
	eState				:	E_MessengerState;
	stDiag				:	ST_fbDiagnostics;
	{attribute 'naming' := 'omit'}
	rtReset				:	R_TRIG;
	fbGetSystemTime		:	FB_LocalSystemTime := (bEnable := TRUE);
	fbGetHostName		:	FB_GetHostName := (bExecute := TRUE, sNetID := '');
	{attribute 'naming' := 'omit'}
	ctuSentSomething	:	CTU := (PV := 100);
	{attribute 'naming' := 'omit'}
	rtSocketSendErr		:	R_TRIG;
	sHostName	:	T_MaxString := csNILVALUE;
END_VAR
VAR CONSTANT
	cPSLogHost	: T_IPv4Addr := '172.21.32.9'; //syslog host
	cnUdpSyslog	:	UDINT := 514; //syslog port
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* Syslog Logger
A. Wallace 2016-9-3

This is used to pass PLC notification messeges to a syslog server.

This POU constantly attempts to send out messages from the global buffer.

*)

fbLoggerBuffer.pBuffer := ADR(asMesgBuffer); 
fbLoggerBuffer.cbBuffer:= UINT_TO_UDINT(SIZEOF(asMesgBuffer));

fbGetSystemTime(); 
IF fbGetSystemTime.bValid THEN
	gsCurrentTime := SYSTEM_TIME_TO_RFC3339(fbGetSystemTime.systemTime);
ELSE
	gsCurrentTime := csNILVALUE;
END_IF

fbGetHostName();
IF NOT (fbGetHostName.bBusy OR fbGetHostName.bError) THEN
	sHostName := fbGetHostName.sHostName;
ELSE
	sHostName := csNILVALUE;
END_IF

IF i_CloseSocket THEN 
	eState := E_MessengerState.CloseSocket; 
END_IF

rtReset(CLK:=i_bReset);
IF rtReset.Q THEN
	eState := E_MessengerState.CreateSocket;
END_IF

rtSocketSendErr(CLK:=fbUDPSocketSend.bError);

CASE eState OF
	E_MessengerState.Init:
		;
	E_MessengerState.CreateSocket:
		fbUDPSocketManager.nLocalPort := cnUdpSyslog;
		fbUDPSocketManager.bEnable := TRUE;
		
		IF fbUDPSocketManager.eState = E_SocketConnectionlessState.eSOCKET_CREATED THEN
			eState := E_MessengerState.Active;
		ELSIF fbUDPSocketManager.bError THEN
			eState := E_MessengerState.Err;
			fbUDPSocketManager.bEnable := FALSE;
			stDiag.fString( sOut=>stDiag.asResults[stDiag.resultIdx.IncVal()], sFormat:='Socketmanger error in createsocket: %d', arg1:=F_UDINT(fbUDPSocketManager.nErrID));
		ELSE
			eState := E_MessengerState.Err;
			stDiag.fString( sOut=>stDiag.asResults[stDiag.resultIdx.IncVal()], sFormat:='Something else happened in createsocket -> error');
		END_IF
	E_MessengerState.Active:
		IF fbUDPSocketManager.eState = E_SocketConnectionlessState.eSOCKET_TRANSIENT  OR 
			fbUDPSocketManager.bError THEN
			eState := E_MessengerState.Err; 
			stDiag.fString( sOut=>stDiag.asResults[stDiag.resultIdx.IncVal()], sFormat:='Socketmanager error in active: %d', arg1:=F_UDINT(fbUDPSocketManager.nErrID));
		END_IF
		
		// While the socket is active, go ahead and send whatever is in the buffer
		IF rtSocketSendErr.Q THEN
			eState := E_MessengerState.Err;
			stDiag.fString( sOut=>stDiag.asResults[stDiag.resultIdx.IncVal()], sFormat:='Socket send error: %d', arg1:=F_UDINT(fbUDPSocketSend.nErrId));
		ELSIF fbLoggerBuffer.nCount > 0 AND NOT fbUDPSocketSend.bBusy THEN
			fbLoggerBuffer.A_RemoveHead(getValue=>sOutgoingMesg);
			fbUDPSocketSend.bExecute := TRUE; //reset in the action after busy goes true
			IF sOutgoingMesg <> '' THEN
				ctuSentSomething(CU:=TRUE);
			END_IF
		ELSIF fbLoggerBuffer.nCount = 0 OR fbUDPSocketSend.bBusy THEN
			stDiag.fString( sOut=>stDiag.asResults[stDiag.resultIdx.IncVal()], sFormat:='Waiting to send');
			ctuSentSomething(CU:=FALSE);
		ELSE
			eState := E_MessengerState.Err;
			stDiag.fString( sOut=>stDiag.asResults[stDiag.resultIdx.IncVal()], sFormat:='Something else happened in active -> error');
		END_IF
		
	E_MessengerState.CloseSocket:
		fbUDPSocketManager.bEnable R= i_CloseSocket;
		IF fbUDPSocketManager.eState = E_SocketConnectionlessState.eSOCKET_CLOSED THEN
			eState := E_MessengerState.Init;
		ELSIF fbUDPSocketManager.bBusy AND NOT fbUDPSocketManager.bEnable THEN
			;
		ELSIF fbUDPSocketManager.bError THEN
			eState := E_MessengerState.Err;
		ELSE
			eState := E_MessengerState.Err;
		END_IF
	E_MessengerState.Err:
		eState := E_MessengerState.Init;
		stDiag.asResults[stDiag.resultIdx.IncVal()] := 'Moving back to Init state from Error';
	ELSE
		eState := E_MessengerState.Init;		
		stDiag.asResults[stDiag.resultIdx.IncVal()] := 'Uncaught state';
END_CASE



Manager();
SocketSendTo();]]></ST>
    </Implementation>
    <Action Name="Manager" Id="{0b30d4fb-bcf3-449a-83ce-64e06542700f}">
      <Implementation>
        <ST><![CDATA[fbUDPSocketManager(hSocket => stUDPSocket);]]></ST>
      </Implementation>
    </Action>
    <Action Name="SocketSendTo" Id="{fca34bf9-1619-4cff-a5ea-95f906bcb6c8}">
      <Implementation>
        <ST><![CDATA[fbUDPSocketSend.hSocket := stUDPSocket;
fbUDPSocketSend.sRemoteHost := cPSLogHost;
fbUDPSocketSend.nRemotePort := cnUdpSyslog;
fbUDPSocketSend.pSrc := ADR(sOutgoingMesg);
fbUDPSocketSend.cbLen := UINT_TO_UDINT(SIZEOF(sOutgoingMesg));
fbUDPSocketSend();
fbUDPSocketSend.bExecute R= fbUDPSocketSend.bBusy;]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="FB_Logger">
      <LineId Id="445" Count="100" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_Logger.Manager">
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_Logger.SocketSendTo">
      <LineId Id="2" Count="5" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>