<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_LogMessage" Id="{0893f9f8-65e8-4db6-822f-019a7a161c6c}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'reflection'}
FUNCTION_BLOCK FB_LogMessage
VAR_INPUT
	sMsg			: T_MaxString; 					// Message to send
	eSevr			: TcEventSeverity	:= TcEventSeverity.Verbose;
	eSubsystem		: E_Subsystem; 					// Subsystem
	sJson			: STRING(7000)	:= '{}';		// JSON to add to the message
    
    //Circuit breaker settings
    nLocalTripThreshold : UINT := GVL_Logger.nLocalTripThreshold; // Local rate for this breaker, events/period
    nTrickleTripThreshold : UINT := GVL_Logger.nLocalTrickleTripThreshold; // Trickle trip, activated by global threshold
    nEventTripPeriod : TIME := GVL_Logger.nEventTripPeriod; // If log events exceed the threshold for this long, trip
    nTripResetPeriod : TIME := GVL_Logger.nTripResetPeriod; // Time for auto-reset
    bEnableAutoReset : BOOL := TRUE; //Enable circuit breaker auto-reset
END_VAR

VAR_OUTPUT
END_VAR

VAR
	bInitialized		:	BOOL := FALSE;
	bInitFailed			:	BOOL := FALSE;
	sSubsystemSource	:	STRING;
	fbMessage			:	REFERENCE TO FB_TcMessage;
	fbMessages 			:	ARRAY [0..4] OF FB_TcMessage;
	fbSource 			:	FB_TcSourceInfo;
	ipResultMessage	 	:	I_TcMessage;
	hr 					:	HRESULT;
	hrLastInternalError :	HRESULT;
	eTraceLevel 		:	TcEventSeverity := TcEventSeverity.Verbose;
	
	{attribute 'instance-path'} 
    {attribute 'noinit'} 
	sPath				:	T_MaxString;
    
    // Circuit breaker
    ///////////////////////////////
        nTotalEvents       :   UINT;
        
        nAccumulatedEvents : UINT := 0;
        aAccumulator : ARRAY [0..nAccWidth] OF UINT;
        nAccIdx : UINT;
        tonAccTimer : TON;
        
        tonAutoTripReset : TON;
 
        bLocalTrickleTripped : BOOL;
        bLocalTripped : BOOL;

        {attribute 'pytmc' := '
            pv: Tripped
            io: i
            field: DESC Log message FB tripped
        '}
        bTripped    :    BOOL; // Won't emit messages if true
        {attribute 'pytmc' := '
            pv: Reset
            io: o
            field: DESC Rising-edge reset of trip
        '}
        bResetBreaker : BOOL;
        rtResetBreaker : R_TRIG;
        
        rtTripped : R_TRIG;
    ////////////////////////////////////////////
      
    idx                 :   UINT;
    
END_VAR
VAR CONSTANT
    nAccWidth : UINT := 10;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bInitialized AND NOT bInitFailed THEN
	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Verbose.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Verbose, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Warning.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Warning, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Info.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Info, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Error.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Error, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Critical.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Critical, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF
	
	IF bInitFailed THEN
		ADSLOGSTR(
			msgCtrlMask := ADSLOG_MSGTYPE_ERROR, 
			msgFmtStr   := '[LOGGER] Initialization failed in %s', 
			strArg      := sPath,
		); 
	ELSE
		bInitialized := TRUE;
	END_IF
END_IF

IF bInitFailed THEN
	RETURN;
END_IF


///////////////////////////////////////
// Log message circuit breaker

CircuitBreaker();
 
///////////////////////////////////////////////////////////


	
// Map the message severity to the LCLSGeneralEventClass:
CASE eSevr OF
	TcEventSeverity.Verbose: 	fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Verbose.nEventId];
	TcEventSeverity.Warning:	fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Warning.nEventId];
	TcEventSeverity.Info:		fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Info.nEventId];		
	TcEventSeverity.Error:		fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Error.nEventId]; 
	TcEventSeverity.Critical:	fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Critical.nEventId];
	ELSE
		RETURN;
END_CASE

CASE eSubsystem OF
	E_Subsystem.FIELDBUS: 	sSubsystemSource := '/Fieldbus';
	E_Subsystem.MOTION: 	sSubsystemSource := '/Motion';
	E_Subsystem.MPS: 		sSubsystemSource := '/MPS';
	E_Subsystem.SDS: 		sSubsystemSource := '/SDS';
	E_Subsystem.VACUUM:		sSubsystemSource := '/Vacuum';
	E_Subsystem.OPTICS:     sSubsystemSource := '/Optics';
	ELSE
		sSubsystemSource := '/Unknown';
END_CASE

// Clearing the source here will clear the event GUID, causing the message to not be resolved.
// However, we can change the name as desired:
//fbSource.Clear();
fbSource.sName := CONCAT(sPath, sSubsystemSource);

ipResultMessage := fbMessage;
hr := fbMessage.CreateEx(stEventEntry:=ipResultMessage.stEventEntry, ipSourceInfo:=fbSource);

// This is where the message text gets appended:
fbMessage.ipArguments.Clear();

IF rtTripped.Q THEN
   fbMessage.ipArguments.AddString('Logging circuit breaker tripped, this will be the last message from this element for a while...');
ELSIF NOT bTripped THEN
    fbMessage.ipArguments.AddString(sMsg); 
END_IF


IF LEN(sJson) = 0 THEN
	// Ensure there's a valid JSON string here
	sJson := '{}';
END_IF

fbMessage.SetJsonAttribute(sJson);

// For a final format of:
// 'Path.to.FB_LogMessage/Subsystem': {Unknown,Error,Warning,Verbose} (message)
// We want to send 1 more message when we trip
IF NOT FAILED(hr) AND fbMessage.eSeverity >= eTraceLevel AND (NOT bTripped OR rtTripped.Q) THEN
	hr := fbMessage.Send(0);
END_IF

IF FAILED(hr) THEN
	hrLastInternalError := hr;
END_IF]]></ST>
    </Implementation>
    <Action Name="CircuitBreaker" Id="{e49ad5c6-bab2-45f9-a152-f716dee29a1a}">
      <Implementation>
        <ST><![CDATA[
tonAutoTripReset(IN:=FALSE);

tonAutoTripReset(
    IN := bTripped AND bEnableAutoReset,
    PT := nTripResetPeriod);
    
rtResetBreaker(CLK:=bResetBreaker);
    
IF tonAutoTripReset.Q OR rtResetBreaker.Q THEN
    bLocalTrickleTripped := FALSE;
    bLocalTripped := FALSE;
    bTripped := FALSE;
    FOR idx := 0 to nAccWidth DO
        aAccumulator[idx] := 0;
    END_FOR
END_IF

nAccumulatedEvents := nAccumulatedEvents + 1; //every time FB_LogMessage is called, it is producing a message
GVL_Logger.nGlobAccEvents := GVL_Logger.nGlobAccEvents + 1;

tonAccTimer(
    IN := NOT tonAccTimer.Q,
    PT := nEventTripPeriod);
    
IF tonAccTimer.Q THEN
    aAccumulator[nAccIdx] := nAccumulatedEvents;
    nAccIdx := nAccIdx + 1 MOD nAccWidth;
END_IF

nTotalEvents := 0;
FOR idx := 0 to nAccWidth DO
    nTotalEvents := nTotalEvents + aAccumulator[idx];
END_FOR
// Also accumulate the current batch (before it's recorded)
nTotalEvents := nTotalEvents + nAccumulatedEvents;

IF GVL_LOGGER.bTrickleTripped THEN
    bLocalTrickleTripped S= nTotalEvents > nTrickleTripThreshold;
ELSE
    bLocalTripped S= nTotalEvents > nLocalTripThreshold;
END_IF

bTripped S= bLocalTrickleTripped OR bLocalTripped;
rtTripped(CLK:=bTripped);

]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>