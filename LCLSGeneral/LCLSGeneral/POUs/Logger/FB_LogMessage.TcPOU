<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_LogMessage" Id="{0893f9f8-65e8-4db6-822f-019a7a161c6c}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'reflection'}
FUNCTION_BLOCK FB_LogMessage
VAR_INPUT
	sMsg			: T_MaxString; 					// Message to send
	eSevr			: TcEventSeverity	:= TcEventSeverity.Verbose;
	eSubsystem		: E_Subsystem; 					// Subsystem
	sJson			: STRING(7000)	:= '{}';		// JSON to add to the message
END_VAR

VAR_OUTPUT
END_VAR

VAR
	bInitialized		:	BOOL := FALSE;
	bInitFailed			:	BOOL := FALSE;
	sSubsystemSource	:	STRING;
	fbMessage			:	REFERENCE TO FB_TcMessage;
	fbMessages 			:	ARRAY [0..4] OF FB_TcMessage;
	fbSource 			:	FB_TcSourceInfo;
	ipResultMessage	 	:	I_TcMessage;
	hr 					:	HRESULT;
	hrLastInternalError :	HRESULT;
	eTraceLevel 		:	TcEventSeverity := TcEventSeverity.Verbose;
	
	{attribute 'instance-path'} 
    {attribute 'noinit'} 
	sPath				:	T_MaxString;
    
    nAccumulatedEvents : UINT := 0;
    aAccumulator : ARRAY [0..nAccWidth] OF UINT;
    nAccIdx : UINT;
    tonAccTimer : TON;
    tonAutoTripReset : TON; 
    
    nLocalTripThreshold : UINT := GVL_Logger.nLocalTripThreshold; // Local rate for this breaker, events/period
    nTrickleTripThreshold : UINT := GVL_Logger.nLocalTrickleTripThreshold; // Trickle trip, activated by global threshold
    nEventTripPeriod : TIME := GVL_Logger.nEventTripPeriod; // If log events exceed the threshold for this long, trip
    nTripResetPeriod : TIME := GVL_Logger.nTripResetPeriod; // Time for auto-reset
    bEnableAutoReset : BOOL := TRUE;
    {attribute 'pytmc' := '
		pv: Tripped
		io: i
		field: DESC Log message FB tripped
	'}
    bTripped    :    BOOL; // Won't emit messages if true
    {attribute 'pytmc' := '
		pv: Reset
		io: o
		field: DESC Rising-edge reset of trip
	'}
    bResetBreaker : BOOL;
    rtTripped : R_TRIG;
      
    idx                 :   UINT;
    nTotalEvents       :   UINT;
END_VAR
VAR CONSTANT
    nAccWidth : UINT := 10;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT bInitialized AND NOT bInitFailed THEN
	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Verbose.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Verbose, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Warning.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Warning, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Info.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Info, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Error.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Error, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF

	hr := fbMessages[TC_EVENTS.LCLSGeneralEventClass.Critical.nEventId].CreateEx(TC_EVENTS.LCLSGeneralEventClass.Critical, 0 (*fbSource*) );
	IF FAILED(hr) THEN
		bInitFailed := TRUE;
		hrLastInternalError := hr;
	END_IF
	
	IF bInitFailed THEN
		ADSLOGSTR(
			msgCtrlMask := ADSLOG_MSGTYPE_ERROR, 
			msgFmtStr   := '[LOGGER] Initialization failed in %s', 
			strArg      := sPath,
		); 
	ELSE
		bInitialized := TRUE;
	END_IF
END_IF

IF bInitFailed THEN
	RETURN;
END_IF


///////////////////////////////////////
// Log message circuit breaker

    nAccumulatedEvents := nAccumulatedEvents + 1; //every time FB_LogMessage is called, it is producing a message
    GVL_Logger.nGlobAccEvents := GVL_Logger.nGlobAccEvents + 1;
    
    tonAccTimer(
        IN := NOT tonAccTimer.Q,
        PT := nEventTripPeriod);
        
    IF tonAccTimer.Q THEN
        aAccumulator[nAccIdx] := nAccumulatedEvents;
        nAccIdx := nAccIdx + 1 MOD nAccWidth;
    END_IF
    
    FOR idx := 0 to nAccWidth DO
        nTotalEvents := nTotalEvents + aAccumulator[idx];
    END_FOR
    
    IF GVL_LOGGER.bTrickleTripped THEN
        bTripped S= nTotalEvents > nTrickleTripThreshold;
    ELSE
        bTripped S= nTotalEvents > nLocalTripThreshold;
	END_IF
        
    tonAutoTripReset(
        IN := bTripped AND bEnableAutoReset,
        PT := nTripResetPeriod);
        
    IF tonAutoTripReset.Q OR bResetBreaker THEN
        bTripped := FALSE;
        FOR idx := 0 to nAccWidth DO
            aAccumulator[idx] := 0;
        END_FOR
    END_IF
 
///////////////////////////////////////////////////////////


	
// Map the message severity to the LCLSGeneralEventClass:
CASE eSevr OF
	TcEventSeverity.Verbose: 	fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Verbose.nEventId];
	TcEventSeverity.Warning:	fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Warning.nEventId];
	TcEventSeverity.Info:		fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Info.nEventId];		
	TcEventSeverity.Error:		fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Error.nEventId]; 
	TcEventSeverity.Critical:	fbMessage REF= fbMessages[TC_EVENTS.LCLSGeneralEventClass.Critical.nEventId];
	ELSE
		RETURN;
END_CASE

CASE eSubsystem OF
	E_Subsystem.FIELDBUS: 	sSubsystemSource := '/Fieldbus';
	E_Subsystem.MOTION: 	sSubsystemSource := '/Motion';
	E_Subsystem.MPS: 		sSubsystemSource := '/MPS';
	E_Subsystem.SDS: 		sSubsystemSource := '/SDS';
	E_Subsystem.VACUUM:		sSubsystemSource := '/Vacuum';
	E_Subsystem.OPTICS:     sSubsystemSource := '/Optics';
	ELSE
		sSubsystemSource := '/Unknown';
END_CASE

// Clearing the source here will clear the event GUID, causing the message to not be resolved.
// However, we can change the name as desired:
//fbSource.Clear();
fbSource.sName := CONCAT(sPath, sSubsystemSource);

ipResultMessage := fbMessage;
hr := fbMessage.CreateEx(stEventEntry:=ipResultMessage.stEventEntry, ipSourceInfo:=fbSource);

// This is where the message text gets appended:
fbMessage.ipArguments.Clear();

IF bTripped THEN
   fbMessage.ipArguments.AddString('Logging circuit breaker tripped, this will be the last message from this element for a while...');
ELSE
    fbMessage.ipArguments.AddString(sMsg); 
END_IF


IF LEN(sJson) = 0 THEN
	// Ensure there's a valid JSON string here
	sJson := '{}';
END_IF

fbMessage.SetJsonAttribute(sJson);

// For a final format of:
// 'Path.to.FB_LogMessage/Subsystem': {Unknown,Error,Warning,Verbose} (message)
rtTripped(CLK:=bTripped);
IF NOT FAILED(hr) AND fbMessage.eSeverity >= eTraceLevel AND (NOT bTripped OR rtTripped.Q) THEN
	hr := fbMessage.Send(0);
END_IF

IF FAILED(hr) THEN
	hrLastInternalError := hr;
END_IF]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>